## Overview

This scaffold outlines a multi-tenant **chapter portal** with robust user onboarding and role-based access control. The goal is to support two signup workflows – **admin-invited onboarding** and **self-service signup via join codes** – while managing user roles (`admin`, `member`, `pending_member`) within each chapter. Building such features in a single app involves implementing invitation flows, membership management, and data segregation per chapter (tenant). We will use **Next.js 15 App Router** for the frontend, **Prisma + PostgreSQL** for data modeling, and integrate **Tailwind CSS** with **shadcn/ui** for UI components. Authentication and authorization are treated as first-class concerns – verifying user identity and then enforcing what each role can access. By following Next.js best practices (using the App Router and appropriate server/client components) and recommended libraries (React Hook Form for forms, Zod for validation, etc.), this scaffold will establish a maintainable foundation for chapter-based membership management.

## Data Models and Relationships

Using Prisma, we define models to represent users, chapters, join codes, invites, and memberships in a PostgreSQL database. Below are the key models and their structure (as an example schema):

* **User** – Represents an application user. Fields include an auto-increment `id`, `email` (unique identifier), `name` (or first/last name), and authentication fields like `passwordHash` if managing credentials. A user can belong to multiple chapters, so we define a one-to-many relation to **Membership** records.

* **Chapter** – Represents a chapter or tenant. Fields include an auto-increment `id`, `name` (e.g. chapter title), and a `slug` (unique string used in URLs to identify the chapter). Each chapter has a **join code** (e.g. `joinCode` field) which is a unique invite string for self-signups. (Alternatively, a separate `JoinCode` model can be used if tracking multiple codes or code metadata, but a simple string field on Chapter suffices for one active code per chapter.) A chapter has many members, modeled via a one-to-many relation to Membership.

* **Membership** – Join table linking **User** and **Chapter**, with an assigned role. This model contains foreign keys `userId` and `chapterId` (both part of a composite primary key to ensure one membership per user per chapter), and a `role` field. The role can be an enum value – for example, `ADMIN`, `MEMBER`, or `PENDING_MEMBER`. Using an explicit join model with a role attribute allows modeling a user’s role within a specific chapter (similar to how one might model a user’s role in a course or organization). For instance, a **Prisma** schema might include:

  ```prisma
  model User {
    id        Int          @id @default(autoincrement())
    email     String       @unique
    name      String?
    passwordHash String?
    memberships  Membership[]
  }
  model Chapter {
    id        Int          @id @default(autoincrement())
    slug      String       @unique
    name      String
    joinCode  String
    memberships  Membership[]
    invites      Invite[]
  }
  model Membership {
    user     User   @relation(fields: [userId], references: [id])
    userId   Int
    chapter  Chapter @relation(fields: [chapterId], references: [id])
    chapterId Int
    role     Role    /// Role is an enum type defined below
    @@id([userId, chapterId])  // composite primary key
  }
  enum Role {
    ADMIN
    MEMBER
    PENDING_MEMBER
  }
  model Invite {
    id         Int    @id @default(autoincrement())
    email      String
    chapter    Chapter @relation(fields: [chapterId], references: [id])
    chapterId  Int
    role       Role    /// role intended for invited user
    token      String  @unique 
    createdAt  DateTime @default(now())
    accepted   Boolean @default(false)
  }
  ```

  In this design, an **Invite** is a separate model containing a unique `token` (used in invite links) and the email of the invitee, linked to a chapter and intended role. The `Invite` record helps facilitate the admin invite flow (more details below). The **join code** for a chapter is stored in the Chapter model (`joinCode` field); it’s a shared secret that prospective members must provide to request access. Each Chapter’s join code should be sufficiently random (e.g. an alphanumeric string like "abc123") and can be regenerated by an admin if needed. This approach – unique chapter codes for sign-up – is used in membership systems (for example, student chapters in FFA have a single shared invite code that members use to create their accounts tied to that chapter).

**Relationships and constraints:** A User can have many Memberships (one per chapter they belong to), and a Chapter can have many Memberships (one per user). The composite key on Membership (`userId, chapterId`) ensures a user doesn’t have duplicate memberships to the same chapter. The `role` enum defines the allowed roles explicitly. We will treat `PENDING_MEMBER` as a role indicating an unapproved membership. This makes it easy to query for pending users and change their role to regular member upon approval. It’s a simple form of status tracking via the role field. (Alternatively, a boolean like `isApproved` could be used, but using the role enum keeps all role logic unified.)

## Roles and Permissions

We define three roles: **admin**, **member**, and **pending\_member**. These roles determine what actions a user can perform and what they can access in the chapter context (authorization):

* **Admin** – Chapter admins have full management rights within their chapter. They can invite new users by email, approve or deny pending sign-up requests, and manage chapter settings (like regenerating the join code or editing chapter info). Admins essentially oversee the chapter’s membership and content. They are the only ones who can see the admin interface routes (like invites and pending approvals pages). In terms of data access, an admin can view all members of their chapter (including pending ones) and all chapter-specific data. This aligns with typical RBAC where an administrator has comprehensive access within their tenant.

* **Member** – Regular members are approved users who have access to the chapter’s main portal functionality. They can view chapter content (e.g. events, resources) and update their own profile information. Members cannot invite others or approve new users; they only have end-user privileges within the chapter. Essentially, once a pending user is approved and becomes a member, they gain normal access to everything in the chapter that is not explicitly admin-only.

* **Pending Member** – A user who has self-signed-up to a chapter but has not yet been approved by an admin. Pending members have extremely limited access: upon logging in, they should only see a **pending approval screen** or message, rather than the normal portal. They cannot see chapter content or interact with most features until an admin grants them full membership. This role exists to ensure **new signups via join code are reviewed** before joining. In practice, a pending member’s experience is restricted to a “Thanks for signing up, your account is awaiting approval” page.

**Permissions and Access Control:** The application must enforce that users can only act within chapters where they have a membership, and only according to their role. For example, only admins can load the `/[chapterSlug]/admin/*` routes, and only members (or admins) can access the main chapter portal pages. If a user tries to access a chapter route that they are not a part of, the app should prevent it – effectively treating it as a 404 Not Found or redirecting them away. *We wouldn’t want just anyone to be able to view another organization’s pages*. This isolation (multi-tenancy) means each request or page render should check the **current chapter context** (derived from the URL slug) against the user’s memberships. If there’s no membership or the role is insufficient, deny access. For pending members, if they attempt to navigate beyond the pending notice, you could redirect them back to the pending screen. This request-and-approval mechanism is essentially a form of **access request workflow**, where a user requests access to a resource and an admin must approve it before access is granted. Only after approval does the user’s role change from `pending_member` to `member`, granting them authorization to use the chapter’s features.

## Admin Invite Flow

In the **admin invite workflow**, an existing chapter admin invites a new user via email, allowing them to onboard directly into the chapter without needing a join code or approval (they are pre-approved by virtue of the invite). This flow is typically used when an admin wants to quickly add colleagues or known members. The high-level steps are:

1. **Admin Initiates Invite:** On the chapter’s admin panel (e.g. the `/[chapterSlug]/admin/invites` page), an admin can send an invite. The UI provides a form where the admin enters the email address of the person to invite, and selects a role for them (either a normal member or another admin). The role selection could default to “member” for safety. When the admin submits, the system generates an invite.

2. **Create Invite Record:** The backend creates an **Invite** entry in the database for that email and chapter. This includes generating a secure random **token** (e.g. a UUID or random string) that will be used in the invitation link. The invite record stores the token, the target email, the chapter it’s for, and the intended role. Because this invited user is effectively approved by the admin, we do not create a pending membership here; instead, we rely on the invite process to create an active membership once the user accepts. (We mark the invite as `accepted = false` initially.)

3. **Send Invitation Email:** Typically, the system would email the invite link to the provided address. The link could be something like: `https://yourapp.com/[chapterSlug]/join?inviteToken=<token>`. (Alternatively, it could be a dedicated route like `/invite/accept?token=...`, which then knows the chapter from the token lookup.) For our scaffolding purposes, emailing can be simulated or handled later – but the main point is the user needs to receive the token to continue. The admin interface might show a confirmation that the invite was sent.

4. **Invite Acceptance (Signup):** The invited user clicks the link and lands on the site. The app finds the invite by the token (e.g. a server-side lookup in `Invite` where token matches and not yet accepted). If the invite is valid, we allow the user to proceed to create an account (since they might be a new user). On the **/\[chapterSlug]/join** page, we detect an `inviteToken` in the URL. In this case, we can skip the join code requirement – the token itself authenticates the intent. We can pre-fill or lock the chapter selection to the one associated with the invite. The user should set up their account (provide name, and choose a password if using email/password auth) and then submit.

5. **Account Onboarded:** Upon form submission in the invite flow, the backend will create the new **User** (if they don't already have an account) and then create a **Membership** linking that user to the chapter with the role specified in the invite (since the invite was pre-approved, use `role = member` or `admin` as stored). This membership is created as an active member (not pending). Then mark the invite as `accepted = true` (and possibly store the userId that accepted it for record). After this, the user can be considered fully onboarded into the chapter. They should be logged in or prompted to log in with the credentials they just set. Once logged in, they will have the appropriate role in that chapter and can access the portal immediately.

6. **Admin-Assigned Role:** The invited user’s role is set by the admin’s choice at invite time. For example, if an admin invites someone to be a fellow admin, the membership created will have `role = admin`. This means that user will immediately have admin privileges on joining. (Use this power carefully – generally an admin would only do this for trusted co-leads.) If the role was left as default member, then the user joins as a normal member.

7. **Edge Cases:** The system should handle if an invite link is used multiple times or is expired. Perhaps once accepted, further attempts with the same token are rejected. If an invitee already exists as a user in the system (maybe they signed up separately earlier), the flow could either create a new membership for the existing user or disallow duplicate invites. A simple approach is to treat the invite link as only for new user signup; if the email is already in use, we might inform them to log in and perhaps automatically link the membership. These are details that can be handled in implementation.

**Implementation notes:** The `/[chapterSlug]/admin/invites` page (or component) should be a **protected route** (only accessible to users with an admin membership for that chapter). It will contain a form. We can use **React Hook Form** for managing input and **Zod** for validating that the email is properly formatted, etc. On form submission, a **server action** or API route handler can be called to create the invite in the database. Generating a token can be done with a library (like UUID) or crypto. For emailing, if we choose to implement it, we could use a service like SendGrid or an SMTP server – but for scaffolding, simply logging the invite link to the console or database is enough to test the flow.

On the receiving end (the join page), if an `inviteToken` is present in the query, the page should call a backend function (server component or API) to look up the invite details: find the chapter and intended role. If not found or invalid, it can show an error ("Invalid or expired invite"). If valid, proceed to show a signup form for that chapter. We might auto-fill the chapter name and hide the join code field in this case, since the token replaces the need for a join code. After the user submits their details, the backend will create the user (with the given email, ensuring it matches the invite email for security) and membership. If using an authentication library, this is also where we’d trigger the creation of the auth record (for example, with NextAuth, you might create the user in the database and perhaps issue a session or ask them to log in). In summary, a successful invite flow results in a new **member** or **admin** in the chapter without further admin action.

## Self Sign-Up via Join Code (Member-Initiated)

The **join code flow** allows individuals to request membership to a chapter on their own, without a direct invite, provided they have the chapter’s join code. This is a “self-service” signup path intended for cases where an admin distributes a join code (e.g. to a group or publicly) and interested people use it to sign up. Because these sign-ups are not pre-approved, they enter as pending members awaiting admin approval. The flow works as follows:

1. **Obtain Join Code:** The prospective member somehow obtains the chapter’s join code (e.g. an admin or leader shares the code with them, or it’s posted on a private forum). For example, a chapter might announce “Use code **ABC123** to join our chapter on the platform.” Each chapter’s code is unique, so it identifies both the chapter and serves as a shared "password" to request access.

2. **Access the Join Page:** The user navigates to the signup page for that chapter. In our route structure, this is `/[chapterSlug]/join`. For instance, if the chapter slug is `demochapter`, the URL might be `https://yourapp.com/demochapter/join`. This page is publicly accessible (no login required) but it is specific to the chapter context. The page will present a **signup form** that typically asks for the user’s details (name, email, password, etc.) and includes a field for the **join code** (unless the code is implicitly known by being at that URL – but to be safe, we usually ask for the code to ensure the user actually knows it and didn't just guess the URL).

3. **User Enters Details and Code:** The user fills in their information and enters the join code provided to them. We should verify the code on the client side if possible (to give quick feedback) and definitely on the server side. Using Zod or similar validation, ensure the code field is not empty and perhaps matches an expected pattern. The form submission can be handled by a server action or API route that processes the new signup.

4. **Validate Join Code:** When the signup request hits the server, the application checks that the provided join code matches the stored code for that chapter. This is a crucial step to prevent unauthorized signups. If the codes do not match, the signup should be rejected (the user can be shown an error like "Invalid join code. Please contact the chapter admin for a valid code."). If the code is correct, we proceed to create the user account. (We also ensure the chapter exists by the slug; if someone somehow tried a non-existent slug, they’d get a 404 before hitting this form.)

5. **Create User & Pending Membership:** Since this is a new signup, we create a new **User** record with the provided email (ensuring uniqueness) and hashed password, etc. (If we integrate with an auth library, it might handle user creation for us based on credentials – for example, NextAuth with credentials provider, or a custom endpoint that hashes password using bcrypt.) After creating the User, we create a **Membership** linking this user to the chapter. The crucial part: this membership’s `role` is set to `PENDING_MEMBER`. This flags the membership as needing approval. The user is not given the `member` role yet. At this point, the database now has the user in a pending state for that chapter.

6. **Post-Signup Feedback:** Upon successful creation, the user experience should reflect that they are not fully in yet. After form submission, you can log the new user in (depending on your auth setup) but then immediately show them a **pending approval screen**. For example, after account creation we might redirect them to `/[chapterSlug]/pending` (a route we create to inform the user of their pending status), or reuse the join page to display a message. The message can be something like: *“Thank you for signing up! Your request to join **ChapterName** is pending approval. You will be notified once an admin approves your membership.”* At this stage, the user cannot access the regular chapter portal. If they try to go to `/[chapterSlug]/portal` or any member page, the app should detect their role is pending and redirect them back to the pending notice or otherwise block access. This ensures the **pending\_member can only see the pending screen after signup**, as required.

7. **Admin Notification (Optional):** In a full implementation, it would be wise to notify the chapter admins that a new user has requested to join. This could be done via email or a notification in-app. For scaffolding, one could simply ensure there’s an indicator on the admin dashboard.

8. **Admin Approval Process:** Now the responsibility shifts to an admin of the chapter. The admin will navigate to the **Pending Requests** page (e.g. `/[chapterSlug]/admin/pending`) to review new join requests. That page will list all Memberships in that chapter with role `pending_member`. For each pending entry, the admin sees the user's name/email (as provided during signup). The admin interface should provide actions to **Approve** or **Deny** each request.

9. **Approve Pending Member:** If the admin approves a request, the backend will update that membership record’s role from `PENDING_MEMBER` to `MEMBER`. This effectively activates the user’s access. After this update, the user is now a normal member in the chapter. We might also record the approval (who approved and when) if needed. The next time the user logs in or refreshes, the app will see their role as member and allow full access. We could even email the user saying "You have been approved! You can now access the chapter." (Nice to have.)

10. **Deny (Reject) Request:** If the admin denies the request, the system should remove or invalidate the membership. A simple approach is to delete the Membership row. This means the user no longer has any tie to that chapter. You might also choose to flag it as denied in case you want an audit log, but from the app’s perspective, deletion is fine. If the user tries to log in thereafter, they will find they have no access to that chapter at all (it will appear as if they never joined). Optionally, you could also delete the User record if you want to completely remove them (for example, if your app is such that users are only ever created through chapter signups, a denied user might not belong to any chapter and could be removed. But careful: if the same person might try multiple times or join other chapters, keeping the user but just removing membership might be better). At minimum, if not deleting the user, you should prevent a denied user from repeatedly trying the same code – maybe if they come back to the join page, you could detect their email exists but was denied and warn that they need to contact admin. These are edge case details; the core is that the pending membership is resolved one way or another.

11. **Join Code Reuse and Regeneration:** The join code itself can be reused by multiple people to request access (it’s not one-time, unlike invite tokens). That means the same chapter join code can create multiple pending members over time. If an admin suspects the code was leaked or abused, they have the option to **regenerate the join code**. Regenerating would create a new random code for the chapter and update it in the database (Chapter.joinCode). After regeneration, the old code would no longer be accepted for new signups. Admins should distribute the new code to legitimate members as needed. This regeneration action could be a button on an admin settings page or on the invites/pending page. Only admins can perform it. (Implementing it would be straightforward: generate new random string, update Chapter record.) Keep in mind that regenerating the code does not affect existing pending memberships; it only affects future sign-up attempts.

**Implementation notes:** The `/[chapterSlug]/join` page can be a React server component that renders a form. It should fetch the chapter name (and maybe some branding) based on the slug, so the user knows which chapter they’re joining. It can be implemented to handle both use cases: if an `inviteToken` is present (admin-invite scenario), skip the code input and handle differently; if not, show the join code input. The form submission can be handled by a form action (since Next.js 15 supports form actions in Server Components) – this would allow writing an async function to create the user and membership on the server easily. Alternatively, one could create an API route at `/api/[chapterSlug]/join` to handle the POST request. In either case, use Prisma to write the new records. Make sure to hash passwords and not store plaintext if managing manually. Integration with an auth system can simplify some of this (for instance, using **NextAuth.js** credential provider to handle signup and login). In the absence of a full auth integration in this scaffold, one can implement a minimal password auth and session cookie for demonstration.

The `/[chapterSlug]/admin/pending` page is a **protected admin page** that queries the database for all `Membership` entries of that chapter with role = `PENDING_MEMBER`. It can render a list (perhaps a table) with each pending user’s info. Next to each entry, an **Approve** and **Deny** button will trigger actions. Those actions could call a server action or an API endpoint (`PATCH /api/chapters/[slug]/members/{id}` for example) to update or delete the membership. After an action, the list should refresh (you can use a mutation followed by revalidation if using React Query, or simply re-fetch the data in a server component after action). Using a UI kit like **shadcn/ui**, we can make use of pre-built components for table, buttons, and modals (if we want a confirmation dialog) to maintain a consistent look and feel.

Throughout the self-signup flow, we are essentially implementing a **request-access approval system** inside our app. The user requests access by providing the correct code (proving they were invited indirectly), and an admin explicitly grants access. This pattern improves security and control, ensuring that even with a leaked join code, an admin still approves who gets in. Only authorized members end up with access to chapter resources.

## Chapter Routes and Access Control

We leverage Next.js 15 App Router’s dynamic routes to structure the application by chapter. The segment `[chapterSlug]` in our routes encapsulates all pages that belong to a given chapter context. For example, the URL `/atlanta/events` and `/newyork/events` could render different data, depending on the chapter slug. In our case, we have routes like:

* **`/[chapterSlug]/join`** – Public page for self-signup to a chapter (using join code or invite token). Accessible to anyone (not logged in) who knows the URL. We will server-render this page with the chapter’s context (e.g., display chapter name) and a signup form. If a user is already logged in and has membership, they wouldn’t normally need this, but we won’t restrict it since it’s used for onboarding. This page should handle both normal join code entries and invite token links as described.

* **`/[chapterSlug]/portal`** – The main chapter portal page for members. This could be a dashboard showing chapter-specific content (events, announcements, etc.). Only logged-in members or admins of that chapter should access this. If a pending member logs in and tries to access it, our logic should detect their role and redirect to the pending notice instead. The portal page (and possibly an entire group of pages under `/[chapterSlug]/portal/*`) will require authentication.

* **`/[chapterSlug]/admin/invites`** – Admin-only page for sending invites. Only users with role admin in the given chapter can access. It presents the invite form and possibly a list of invites sent (could show pending invites or allow re-sending, etc., though not strictly required).

* **`/[chapterSlug]/admin/pending`** – Admin-only page listing pending membership requests, as detailed above. Only chapter admins can load this page.

* **(Optional)** `/[chapterSlug]/pending` – A page to show the “pending approval” message to users who have signed up but not yet approved. This could be a simple page saying “Awaiting Approval” that is shown to the user upon login if their membership is still pending. We can choose to implement this as a separate route, or simply incorporate the message in the portal page conditionally. Having a dedicated route might simplify redirection logic (we can send pending users to `/[slug]/pending` upon login). Either way is fine. For clarity, we can create this page so that if a pending member somehow lands on the portal, we redirect them here.

* **`/[chapterSlug]` (root)** – We might have a default index page for a chapter, perhaps redirecting to `/[chapterSlug]/portal` or showing a welcome page. This isn’t strictly specified, but it’s often useful. For example, visiting the bare chapter URL could check: if user not logged in, maybe prompt login or join; if logged in and a member, go to portal; if logged in and pending, go to pending screen. This can be handled via route logic.

**Next.js App Router structure:** Under the `app` directory, we will have a folder `[chapterSlug]` which contains subfolders for `admin`, etc. For example:

```
app
 └─ [chapterSlug]/
     ├─ page.tsx            (perhaps redirects or portal overview)
     ├─ join/page.tsx       (self signup page)
     ├─ portal/page.tsx     (main member portal page)
     ├─ pending/page.tsx    (pending notice page for user awaiting approval)
     └─ admin/
         ├─ invites/page.tsx  (admin invite management)
         └─ pending/page.tsx  (admin pending requests)
```

We can also include shared layouts. For instance, `app/[chapterSlug]/layout.tsx` can define a layout that all chapter pages share (like a navigation bar specific to the chapter, or it could fetch the chapter info). In that layout, crucially, we could perform an **authentication check**: e.g., call a function to get the current user session and verify their membership for the `[chapterSlug]`. This way, for any request under a chapter, we ensure the user is entitled to it. If the user is not logged in, you might redirect them to a login page. If they are logged in but have no membership in that chapter, you could throw a 404 or redirect to a generic dashboard. If they are pending, you could redirect them to the pending notice. By centralizing this logic in a layout or middleware, we don’t have to repeat it on every page. (Next.js 13+ App Router supports a `middleware.ts` at the root for advanced use cases, but since our routes are dynamic by slug, handling inside the layout or individual pages might be simpler.)

**Chapter slug context:** Using the dynamic route `[chapterSlug]` allows us to easily capture which chapter a page is for. For example, if we have a custom hook or utility to get the current chapter from the URL (similar to reading `orgName` in multi-tenant examples), we can use it throughout the pages to filter data. All database queries should include the `chapterId` or slug filter to ensure data separation. For instance, when a member views events, the query would be `WHERE chapterId = ...` matching the slug’s chapter. This guarantees that even if a logged-in user manipulates URLs, they cannot fetch another chapter’s data because the server will always check their membership and the chapter filter before returning anything. This isolation upholds the multi-tenant security model.

To enforce admin-only access on admin routes, we can implement checks in those page files or their parent layout. For example, `app/[chapterSlug]/admin/layout.tsx` could check `if currentUser.role !== 'ADMIN'` for that chapter and redirect out. Or inside each admin page’s server component, do a check and `redirect('/')` if not admin. This ensures even if a non-admin somehow tries to navigate there, they get denied.

**Authentication integration:** So far, we’ve described the flows assuming we have some way to register and log users in. In a real app, we would integrate something like **NextAuth.js (Auth.js)** for session management. NextAuth can work with Credentials (email/password) or magic links, etc. Using NextAuth in the App Router is supported (as of v5 in beta for Next.js 13+). It would handle session cookies and provide us with `useSession` or server-side helpers to get the user. The scaffold can be built with or without NextAuth. If using NextAuth, we’d configure it to use our Prisma adapter so that when we create a User (or use an invite), it ties into NextAuth’s user model. NextAuth would make it easier to protect pages (with its middleware or `getServerSession` checks) and to handle things like password hashing, email sign-in, etc. It "abstracts away much of the complexity involved in managing sessions, sign-in and sign-out, and other aspects of authentication", which can save time.

For the purposes of the scaffold, one can initially scaffold the pages and database without fully wiring NextAuth, but leave hooks for it (e.g., after creating a user, you might want to log them in or at least indicate where NextAuth signup could occur). If not using NextAuth, a custom auth solution can be put in place (e.g., issue a JWT or session cookie upon signup/login).

In summary, each chapter acts as a siloed section of the app, identified by the URL slug, and all membership and role checks revolve around that context. By using dynamic routing and server-side checks, we ensure users see only what they are meant to. If a user is not part of a chapter, they’ll get a "Not Found" or be prevented from viewing it. If a user is pending, they’ll only see the pending page. This design, combined with the invite and join code workflows, satisfies the requirement that *“all user auth is scoped per chapter via slug.”*

## Tech Stack & Implementation Notes

**Next.js 15 App Router:** We utilize the latest Next.js App Router features for a modern file-based routing and React server components. The project structure will follow Next.js conventions, splitting client and server components appropriately. For example, forms that handle data submission can use server actions (a feature in React 18/Next 13+ that allows form data to be handled by a server-side function in the same file). This can simplify our implementation of the invite form and join form. We should also take advantage of Next.js layouts for shared UI (like chapter navigation) and possibly leverage the built-in loading and error UI conventions for better UX. Following Next.js best practices ensures our code remains organized.

**Prisma & PostgreSQL:** Prisma will serve as the ORM for database interactions. After defining the models (as above), we will run `prisma migrate dev` to apply schema changes to the PostgreSQL database. Ensure that the database connection URL is set in the environment (e.g., `.env` file) and that the role enum is handled (Prisma will create a PostgreSQL ENUM for the Role type). We might also set up some initial seed data: for instance, creating a default chapter and an initial admin user for testing. That way, we can easily simulate inviting and joining. The Prisma client will be used in our server components or API routes to query and mutate data. Because we’re scoping everything by chapter, most queries will include a `where chapterId: ...` condition or start from the chapter relation (e.g., `prisma.chapter.findUnique({ where: { slug }, include: { memberships: ... } })`).

**Tailwind CSS & shadcn/ui:** The project will use Tailwind CSS for styling utility classes. We need to configure Tailwind (ensuring the `content` in tailwind.config.js covers the `app` directory). shadcn/ui is a collection of reusable components built on Radix UI and Tailwind – we will use it to scaffold common UI elements like forms, buttons, dialogs, and possibly table/list components. Typically, one would install shadcn/ui components by running the CLI commands (for example, `npx shadcn-ui@latest init` and then adding specific components). For our needs, components such as **Form** (which integrates with React Hook Form), **Input**, **Button**, **Dialog** (for confirming denial maybe), **Table** (for listing pending members) will be useful. Using shadcn’s pre-styled components accelerates development and keeps consistency. We won’t need to custom-build every UI element – instead we compose these building blocks. For instance, a form using shadcn’s `<Form>` component can easily integrate Zod schemas to validate the join code and email on the client side, providing instant feedback.

**Client-side vs Server-side logic:** With Next.js App Router, we can keep most heavy logic server-side. Signup and invite processing should definitely be on the server (never trust the client for approval logic). We will send minimal data to the client. Also, for security, when validating join codes or invite tokens, do it on the server to avoid exposing any secret. The client just submits the token or code; the server checks against the DB. For the admin pages, listing pending members can be done by fetching on the server (since it’s an authorized page, the server already knows the user and can query pending memberships). This can then be rendered in a table UI on the client. Approve/Deny actions can either be form submissions (e.g., each entry with a small form with a hidden field and an action endpoint to approve or deny) or via fetch requests to an API route. Simplicity and reliability of server actions might be preferable – for example, a form with an "Approve" button that, when clicked, triggers a server action function to update the membership. The page would then refresh showing that entry gone.

**Authentication:** As noted, integrating NextAuth would provide a robust solution for handling sessions. In our scaffold, we assume standard email/password authentication. The Next.js middleware or layout will check `request.cookies` for a session token or use NextAuth’s `getServerSession`. If not present or invalid, redirect to a global login page. We should at least stub out that logic. In development, one could also simply use credentials and store a session in-memory for testing. Regardless of method, after a user signs up (via join or invite), log them in so that the next page load knows who they are. NextAuth or a similar library can simplify this by providing `signIn` and `signOut` methods.

**Additional considerations:**

* **Email deliverability:** Ensure to configure an SMTP or email service if implementing actual invites/notifications. For now, you might output the invite links to console or have a page where an admin can copy the invite link to share manually.
* **Form error handling:** Use React Hook Form + Zod to display errors like "Email already exists", "Invalid join code", etc., nicely on the join form. The server action can throw an error that we catch and show to the user.
* **Security:** The join code, invite tokens, and password handling all need to be secure. Join codes should be hard to guess (random strings) and ideally of a decent length. Invite tokens should be long random strings (or UUID v4) and one-time use. Passwords must be hashed (using bcrypt or a similar algorithm on the server). Also consider rate limiting join attempts to avoid brute force on the join code. Using nextjs middleware, you could add basic rate-limit per IP on hitting the join API.
* **Regenerating Join Code:** When an admin clicks "Regenerate Code", generate a new random code (e.g., using Node's crypto or a package) and update the chapter. Possibly show the new code to the admin so they can copy it. Once changed, ensure any old pending invite who might have known the old code but not yet signed up will be invalidated (which is usually fine).
* **Audit Trail:** In a real scenario, it might be useful to keep track of who approved or denied a member (e.g., store the admin user ID who performed the action). This could be an extension to the Membership model or a separate log. Our basic model doesn’t include it, but it’s something to consider if needed.

With this setup in place, we have a complete scaffold for the membership workflow. To summarize, we used **Next.js 15** with the App Router for a multi-tenant structure, **Prisma** for the database models (User, Chapter, Membership, Invite, JoinCode logic), and implemented two onboarding flows: one where admins proactively invite users (who skip the pending state), and one where users self-register using a chapter code (entering a pending state until an admin approves them). We also outlined role-based page access, ensuring admins, members, and pending members each get the appropriate level of access. Following these guidelines and best practices (Tailwind for styling, Shadcn UI for components, Hook Form + Zod for forms, etc.) will result in a clean, maintainable codebase. This scaffold can be placed in a Windsurf Editor task file (e.g., `.windsurf/task/chapters-onboarding.md`) to guide the AI agent in generating the project structure and code. By feeding these detailed requirements and models into Windsurf, the agent (Cascade) should be able to create the necessary files (pages, components, schema) and possibly even some initial code implementations, accelerating the development of the full feature set.
